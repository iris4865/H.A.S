서버
1. 네트워크 리스너에서 비동기로 클라이언트의 접속을 받아들인다.
2. 네트워크 리스너는 현재 한개. 
3. 토큰은 소켓의 확장팩 느낌
4. 4개의 매니저 클래스들이 있는데. 매니저 클래스들은 싱글톤 패턴을 이용해서 만들어 졌다.
  장점은 전역변수는 컴파일 타임에 메모리 할당되지만 싱글톤을 이용할경우 런타임에서 메모리 할당이 이루어 진다.
5. 비동기 객체 매니저(풀) : 비동기 통신을 하기위해서는 비동기 객체가 필요로 하는데 대량의 클라이언트가 접속할경우 매번 객체할당이
			이루어지면 객체할당에는 소모되는 비용이 크기때문에 서버에 부담이 많이간다.
			그래서 풀링(미리 많이 생산해 놓는것)을 하여 런타임에서의 서버부하를 줄인다.
			반복되서 이용되는 기능이기때문에 미리 할당해놓는다. 재사용하려고
6. 버퍼 매니저(풀) : 비동기 객체에 데이터를 저장하기 위해서는 별도의 메모리할당 해야하는데 마찬가지로 이러한 버퍼를 풀링해서 사용한다.
7. 패킷 매니저(풀) : 패킷을 100개를 한번에 쓸수도 있고 하니까 나중에 재사용을 위해서 미리 할당.
8. 넘버링 매니저(풀) : 게임오브젝트들에게 별도의 아이디를 부여하기위해서 미리 풀링을 해놓는다. 클라이언트가 요청해야 그때서 준다.


클라이언트 
1. 사용자는 게임을 실행시키고 로그인화면으로 진입.
2. 커넥트 컨트롤러가 실행되서 서버와 연결을 시도합니다. 
3. 사용자가 로그인 아이디를 입력하여 로그인이 정상적으로 이루어질경우 로그인 허락에 대한 프로토콜을 받는다.
4. 근데 이때 내부적으로 네트워크매니저에서 서버에게 로그인에 대한정보를 전송한다.
5. 서버에서는 디비를 확인하여 등록되있는 사용자면 로그인 허락을 해준다.
6. 게임 플레이에 접속한 유저는 플레이어를 만들어 달라는 요청과 해당 게임 오브젝트를 위한 식별자를 요청한다.
7. 서버에서는 해당 식별자를 키로 이용하여 어떠한 객체인지를 보관한다.
8. 서버에서 처리가 이루어지면 최종적으로 클라이언트에게 게임 오브젝트 만드는것을 허락한다.
9. 게임 오브젝트에서 동기화가 필요한 데이터를 매 프레임마다 서버로 보내 다른 클라이언트들과 동기화 한다.
10. 네트워크 이벤트 매니저 : 패킷의 송수신 순서가 중요한 처리를 위해 순서를 정확하게 지켜서 처리하기
			 위해 패킷을 보관하는 큐를 만들어
			 처리한다. 